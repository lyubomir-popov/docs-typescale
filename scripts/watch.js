const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const chokidar = require('chokidar');

// Ensure chokidar is installed
try {
  require('chokidar');
} catch (e) {
  console.log('Installing chokidar for file watching...');
  execSync('npm install --save-dev chokidar', { stdio: 'inherit' });
}

const CONFIG_PATH = 'config/typography-config.json';
const TOKENS_PATH = 'dist/tokens.json';
const GENERATED_STYLES_PATH = 'src/_generated-styles.scss';
const CSS_OUTPUT_PATH = 'dist/main.css';

function generateTokens() {
  try {
    console.log('ðŸ”„ Generating tokens from baseline nudge generator...');
    execSync('npx @lyubomir-popov/baseline-nudge-generator generate config/typography-config.json', { stdio: 'inherit' });
    console.log('âœ… Tokens generated successfully');
    return true;
  } catch (error) {
    console.error('âŒ Failed to generate tokens:', error.message);
    return false;
  }
}

function createVanillaOverrides() {
  try {
    if (!fs.existsSync(TOKENS_PATH)) {
      console.error('âŒ Tokens file not found. Run the generator first.');
      return false;
    }

    const tokens = JSON.parse(fs.readFileSync(TOKENS_PATH, 'utf8'));
    
    // Update vanilla overrides file
    updateVanillaOverrides(tokens);
    
    // Generate baseline-aligned styles file
    generateBaselineStyles(tokens);
    
    // Ensure directories exist
    if (!fs.existsSync('src')) {
      fs.mkdirSync('src', { recursive: true });
    }
    if (!fs.existsSync('dist')) {
      fs.mkdirSync('dist', { recursive: true });
    }

    // Compile SCSS to CSS
    console.log('ðŸ”„ Compiling SCSS to CSS...');
    execSync(`npx sass --load-path=node_modules src/main.scss ${CSS_OUTPUT_PATH} --style=compressed`, { stdio: 'inherit' });
    console.log('âœ… CSS compiled successfully');
    
    return true;
  } catch (error) {
    console.error('âŒ Failed to create vanilla overrides:', error.message);
    return false;
  }
}

function updateVanillaOverrides(tokens) {
  try {
    const automatedOverridesPath = 'src/_vanilla-settings-automated-overrides.scss';
    
    // Generate automated overrides content completely from scratch
    let automatedContent = `// =============================================================================
// AUTOMATED VANILLA SETTINGS OVERRIDES
// =============================================================================
// This file is auto-generated from config/typography-config.json
// Do not edit manually - changes will be overwritten

// Generated from baseline nudge generator tokens
// Last updated: ${new Date().toISOString()}

// Font family from config
$font-family-base: '${tokens.font}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;

// Baseline unit from config
$baseline-unit: ${parseFloat(tokens.baselineUnit)}rem;

// Typography scale overrides from config
`;



    // Ensure src directory exists
    if (!fs.existsSync('src')) {
      fs.mkdirSync('src', { recursive: true });
    }

    fs.writeFileSync(automatedOverridesPath, automatedContent);
    console.log('âœ… Automated vanilla settings overrides updated');
    
    return true;
  } catch (error) {
    console.error('âŒ Failed to update automated vanilla overrides:', error.message);
    return false;
  }
}

function generateBaselineStyles(tokens) {
  try {
    // Generate baseline-aligned styles content
    let stylesContent = `// =============================================================================
// GENERATED STYLES
// =============================================================================
// This file is auto-generated by the baseline nudge generator
// Do not edit manually - changes will be overwritten

// Generated from baseline nudge generator tokens
// Last updated: ${new Date().toISOString()}

// Override vanilla framework heading styles with baseline-aligned versions
`;

    // Generate baseline-aligned classes for each element
    Object.entries(tokens.elements).forEach(([element, styles]) => {
      const fontSize = parseFloat(styles.fontSize);
      const lineHeight = parseFloat(styles.lineHeight);
      const spaceAfter = parseFloat(styles.spaceAfter);
      const nudgeTop = parseFloat(styles.nudgeTop);
      const marginBottom = spaceAfter - nudgeTop;

      // Generate full CSS rules that override vanilla framework defaults
      stylesContent += `${element} {
  font-size: ${fontSize}rem;
  line-height: ${lineHeight}rem;
  font-weight: ${styles.fontWeight};
  padding-top: ${nudgeTop}rem;
  margin-bottom: ${marginBottom}rem;
  margin-top: 0;
  font-family: $font-family-base;
}

`;
    });

    // Ensure src directory exists
    if (!fs.existsSync('src')) {
      fs.mkdirSync('src', { recursive: true });
    }

    // Write generated styles file (completely overwrite)
    fs.writeFileSync(GENERATED_STYLES_PATH, stylesContent);
    console.log('âœ… Generated styles updated');
    
    return true;
  } catch (error) {
    console.error('âŒ Failed to generate baseline styles:', error.message);
    return false;
  }
}

function processFiles() {
  console.log('\nðŸ”„ Processing typography changes...');
  
  if (generateTokens()) {
    createVanillaOverrides();
  }
  
  console.log('âœ… Processing complete\n');
}

// Check if build-only mode is requested
const isBuildOnly = process.argv.includes('--build-only');

if (isBuildOnly) {
  console.log('ðŸ”¨ Building once...');
  processFiles();
  process.exit(0);
}

// Set up file watcher
console.log('ðŸ‘€ Watching for changes in typography config and SCSS files...');
console.log('ðŸ“ Watching:', CONFIG_PATH, 'and specific SCSS files');

const watcher = chokidar.watch([CONFIG_PATH, path.join(process.cwd(), 'src/main.scss'), path.join(process.cwd(), 'src/_vanilla-settings-overrides.scss'), path.join(process.cwd(), 'src/_generated-styles.scss')], {
  persistent: true,
  ignoreInitial: false,
  usePolling: true,
  interval: 1000
});

watcher.on('change', (path) => {
  console.log(`ðŸ“ File changed: ${path}`);
  
  if (path === CONFIG_PATH) {
    // Typography config changed - regenerate tokens and styles
    processFiles();
  } else if (path.endsWith('.scss')) {
    // SCSS file changed - just recompile CSS
    console.log('ðŸ”„ Recompiling SCSS to CSS...');
    try {
      execSync(`npx sass --load-path=node_modules src/main.scss ${CSS_OUTPUT_PATH} --style=compressed`, { stdio: 'inherit' });
      console.log('âœ… CSS recompiled successfully');
    } catch (error) {
      console.error('âŒ Failed to recompile CSS:', error.message);
    }
  }
});

watcher.on('error', (error) => {
  console.error('âŒ Watcher error:', error);
});

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Stopping watcher...');
  watcher.close();
  process.exit(0);
});

console.log('ðŸš€ Watcher started. Press Ctrl+C to stop.'); 